# STM32 Rotary Encoder OLED Display Project

This project demonstrates a classic embedded system application: using a rotary encoder to control a value displayed on an I2S OLED screen, all driven by an STM32F103C8T6 microcontroller. The entire software development was done using the Keil MDK environment, with initial configuration generated by STM32CubeMX.

## Features

- **Real-time Input**: Increment or decrement a counter by turning a rotary encoder.
- **Instant Feedback**: The updated counter value is immediately displayed on a 0.96" OLED screen.
- **Interrupt-driven**: The rotary encoder logic is handled efficiently within a GPIO external interrupt, minimizing CPU load.
- **HAL Library Based**: The project is built upon the STMicroelectronics HAL library, ensuring good portability and code structure.

## Hardware Components

| Component | Model/Type | Description |
| :--- | :--- | :--- |
| Microcontroller | STM32F103C8T6 | The "Blue Pill" minimal system board. |
| Display | 0.96" I2C OLED | SSD1306 driver, 128x64 resolution. |
| Input Device | EC11 Rotary Encoder | Standard 5-pin module with switch. |
| Prototyping | Breadboard | For easy and solderless connections. |
| Debugger | ST-Link V2 | For programming and debugging. |

## Hardware Connections

| Device Pin | STM32 Pin | Function |
| :--- | :--- | :--- |
| **Rotary Encoder** | | |
| `CLK` (Phase A) | `PA0` | Triggers external interrupt on rising edge. |
| `DT` (Phase B) | `PA1` | Read to determine rotation direction. |
| `+` (VCC) | `3.3V` | |
| `GND` | `GND` | |
| **OLED Display** | | |
| `VCC` | `3.3V` | |
| `GND` | `GND` | |
| `SCL` | `PB6` | I2C1 Clock |
| `SDA` | `PB7` | I2C1 Data |

![Hardware Connection Photo](path/to/your/photo.jpg) 
*(Optional: You can add a photo of your setup here. Upload the image to your repository and replace the path.)*

## Software Implementation

### 1. STM32CubeMX Configuration

- **System Clock**: Configured to use the external HSE crystal (8MHz) and PLL to run the system at its maximum speed of 72MHz.
- **I2C1**: Enabled in standard mode (100kHz) to communicate with the OLED display.
- **GPIO**:
    - `PA0` configured as `GPIO_EXTI0` (External Interrupt on Rising Edge) with an internal pull-up resistor.
    - `PA1` configured as a standard GPIO Input with an internal pull-up resistor.
- **NVIC**: `EXTI0_IRQn` interrupt was enabled to handle the encoder's CLK signal.

### 2. Core Logic

- **Rotary Encoder**: The core logic resides in the `HAL_GPIO_EXTI_Callback()` function. When a rising edge is detected on `PA0` (CLK), the state of `PA1` (DT) is immediately read. Based on this state, a global `volatile int32_t counter` is either incremented or decremented. This phase-difference reading metoda is a standard way to decode quadrature encoders.
- **OLED Display**: A third-party SSD1306 library was integrated. The `while(1)` main loop continuously performs a "re-draw" cycle:
    1. A character buffer is prepared using `sprintf` to convert the `counter` value to a string.
    2. A specific area of the screen buffer is cleared (or the whole buffer is cleared).
    3. Static text ("Value:") and the dynamic number string are written to the screen buffer.
    4. The `ssd1306_UpdateScreen()` function is called to transmit the buffer's content to the OLED via I2C.

## Project Development and Debugging Journey (A Retrospective)

This project, while simple in concept, presented a series of classic embedded development challenges. The debugging process was a valuable learning experience:

1.  **Compiler Errors - The Library Integration Phase**:
    - **Problem**: Encountered a cascade of "file not found" errors (`_ansi.h`, `ssd1306_conf.h`, `stm32f0xx_hal.h`).
    - **Cause**: The third-party OLED library was not perfectly compatible with the Keil/ARMCC toolchain out-of-the-box and required manual configuration.
    - **Solution**: Systematically resolved each error by:
        - Commenting out GCC-specific includes.
        - Creating and configuring the required `ssd1306_conf.h` file.
        - Forcing the inclusion of the correct `stm32f1xx_hal.h` after discovering that the library's preprocessor macros were not working as expected with the CubeMX-generated project definitions.

2.  **Compiler Errors - The "Avalanche Effect"**:
    - **Problem**: A sudden explosion of over 50 errors related to undefined system types like `IRQn_Type`.
    - **Cause**: Traced back to a single root cause: the library contained non-standard macros (`_BEGIN_STD_C`/`_END_STD_C`) that the Keil compiler didn't recognize. This single syntax error broke the parser, leading to a chain reaction of failures in subsequent system headers.
    - **Lesson**: **Always focus on the very first error in a long list of compiler messages.**

3.  **Runtime Logic Errors - The "Blink-and-Die" Phenomenon**:
    - **Problem**: The OLED would display the initial screen for a moment upon reset, then go blank, despite the encoder logic working (verified by debugger).
    - **Cause**: An initial investigation pointed to an incorrectly structured `while(1)` loop where the display refresh code was accidentally placed outside the main loop's scope due to misplaced CubeMX user code markers.
    - **Lesson**: Code structure and adherence to framework conventions (like CubeMX's `/* USER CODE BEGIN */` blocks) are critical for correct program flow.

4.  **Hardware/Physical Layer Errors - The "It Works After Replugging" Mystery**:
    - **Problem**: Even with perfectly correct software logic (verified by the Keil debugger), the OLED screen would still fail to update after the first frame. The issue was magically resolved by unplugging and replugging the Dupont wires.
    - **Cause**: This pointed servi√ßos to a physical layer issue. The most likely culprits were:
        - **Poor Contact**: Intermittent connection on the breadboard or Dupont connectors.
        - **I2C Bus Instability**: The OLED module's built-in I2C pull-up resistors were likely just barely sufficient. A poor connection increased line impedance, causing signal integrity to fail. Re-plugging temporarily created a better connection.
    - **Lesson**: **When the software is confirmed to be correct via a debugger, the problem is almost certainly in the hardware.** Understanding the physical requirements of protocols like I2C (e.g., the need for proper pull-up resistors) is non-negotiable for system stability.

## How to Use

1.  Clone this repository.
2.  Open the project file (`.uvprojx`) in Keil MDK.
3.  Ensure you have the required STM32F1 HAL library pack installed.
4.  Compile the project and flash it to your STM32F103C8T6 board using an ST-Link debugger.
5.  Power on the circuit and observe the OLED display as you turn the rotary encoder.